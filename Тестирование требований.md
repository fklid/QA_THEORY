 Чек-лист тестирования требований

    Тестирование IT-систем,
    Подготовка технической документации

Когда разрабатывается новая функциональность системы, аналитик пишет требования, а тестировщик их проверяет. До того, как начать реализацию. Потому что на этом этапе внести исправления дешевле всего.

Вот только на что обращать внимание при тестировании? Есть набор основных характеристик, которыми должна обладать хорошая документация:

    Полнота

    Однозначность

    Непротиворечивость

    Необходимость

    Осуществимость

    Тестируемость

Конечно, их может быть и больше. Кто-то использует мнемонику CIRCUS MATTA, кто-то расширяет список под себя и команду. Но эти шесть характеристик — основные. О них и в книгах по тестированию пишут, и в самых разных статьях.

В этой статье я расскажу о каждой из них поподробнее, с картиночками и примерами из жизни.

 
1. Полнота

Все ли описано? Ничего не забыли? Вдруг у нас остался неописанный функционал или параметр API-метода?

Чтобы проверить этот пункт, просто напишите чек-лист проверок функционала. Вот как начали читать ТЗ, сразу записывайте тесты. Важно именно писать, а не просто прикидывать в уме. Иначе что-то обязательно забудете.

    Как-то раз мне прислали на проверку ТЗ на новый функционал. Да, по хорошему надо сразу прикинуть тесты, которые буду писать. А это надо взять ручку, блокнот и начать тест-дизайнить... Но я занималась другой задачей, а ТЗ надо проверить «сегодня», чтобы отправить оценку заказчику.

    Поэтому решила проверить «мысленно». Читаю пункт ТЗ, прикидываю, какие могут быть тесты. В итоге задала парочку уточняющих вопросов:

    — А что, если... ?

    У Заказчика уточнили, документацию пополнили! В остальном меня всё устроило, вроде нормально описано, всё учтено.

    Заказчик согласовал ТЗ, разработчик сделал. Пришло время тестировать. Начинаю писать автотесты и... Да, разумеется, сразу получаю еще 5-10 дополнительных вопросов. В ТЗ не были предусмотрены все сценарии, и я о них тоже не подумала, пока прикидывала тесты мысленно.

    А как только стала расписывать план автотестов, сразу увидела «белые пятна». При этом у меня 10 лет опыта в тестировании. Не полагайтесь на память и «быстренько мысленно прикину», выделите полчаса и распишите чек-лист проверок подробно.

 

    Чем плохо отложить вопросы на потом? Не слишком профессионально согласовать требования, которые написала твоя команда, а через пару недель задавать уточняющие вопросы. Заказчик подумает: а чего сразу не спросили?

    Плюс иногда можно пропустить очень важный вопрос, который трудозатратно делать. А ТЗ, напомню, уже согласовано. Так что всё, что продолбали на этапе согласования, делаем за свой счет.

Да, написать тесты — это дольше, чем просто прочитать документацию. Но зато вы экономите время потом, ведь чек-лист уже готов, бери да проверяй!

 
2. Однозначность

Требования должны трактоваться всеми одинаково.

«Отчет должен загружаться быстро» → что значит «быстро»?

    пользователь будет уверен, что страница будет грузиться доли секунды, даже если это сложный отчет на многомиллионных данных;

    разработчик прикинет, что в таких объемах 5 секунд нормальное время отклика, даже быстрое. 

Налицо конфликт интересов. И ведь каждый будет тыкать в ТЗ для отстаивания своей позиции. Лучше конкретизировать:

    Отчет за год должен загружаться не более секунды.

    Отчет за весь период времени должен загружаться не более 5 секунд.

Если в требованиях не указано, что у нового поля с суммой дохода должно быть значение по умолчанию:

    Аналитик будет думать, что там будет значение 0. Деньги же, цифра!

    Разработчик сделает пустое поле, не указано ведь ничего! А это что-то сломает...

Если в требованиях не указано, как обработать ошибочный сценарий, разработчик может:

    Не подумать о нем и никак не обработать — пользователь может огрести страшную ошибку.

    Подумать о нем и обработать так, как считает правильным — а тестировщик потом будет доказывать, что надо было делать по другому. Пойдут к аналитику, потратят и его время тоже, а потом еще код переделывать...

Все, что можно прочитать двояко, лучше исправить. Это не значит, что нужно описывать каждую мелочь, но всё зависит от читателей документа.

Если это внутренний документ, а у вас сильная команда — можно не расписывать подробно.

Если этот документ отправят заказчику, надо расписать вообще всё — потому что у заказчика свои тестировщики, и они обязательно зададут кучу «а что, если...?». Если они хорошие тестировщики, разумеется. Это вы знаете свою программу и представляете, как она реагирует на ошибки или что-то такое. Тестировщик заказчика этого не знает, он будет уточнять.

 
3. Непротиворечивость

Требования не должны противоречить сами себе. Такое обычно бывает, когда требований много. Аналитик просто забывает, что уже писал про параметр и снова придумывает его поведение. Иногда придумывает немного по другому.

Например, есть страница нефункциональных требований, где написано, что любая страница должна грузится не более 3 секунд. Аналитик пишет ТЗ на новый модуль отчетности, который использует много данных и сложные формулы. И он пишет, что отчет может грузиться вплоть до минуты. Явное противоречие!

Если заказчик найдет первый раздел документации, он будет требовать именно такую скорость. И будет прав, кто же хочет ждать?)

 
4. Необходимость

Помните главный принцип: «Кратко, но емко»? Он действует и в документации тоже.

Круто, когда документация полная. Но это не значит, что простой функционал надо растечь на 10 листов А4. Когда документации много, сложно проверить полноту, сложно удержать в голове, о чем уже говорил, не повторяться и не противоречить самому себе.

Подумайте, так ли уж нужно описывать каждую кнопочку интерфейса? Это правда актуально? Пользователи правда не догадаются, что фильтры по строковым колонкам работают одинаково?

Пишите только то, что необходимо:

    В ТЗ — функционал, основной сценарий и альтернативы, типы ошибок.

    В пользовательской документации — то, как пользоваться системой. Но не доходя до крайностей и обучения включению компьютера.

 

 
5. Осуществимость

А можно ли реализовать то, что тут написано? Насколько это будет сложно и дорого?

Этот пункт обычно проверяют разработчики. Они остужают буйные фантазии из серии «загружать миллионы данных за 0,1 секунду» или что-то архитектурно сложное. Бывает такое, что на бумаге всё звучит просто, а вот сделать это займет человеко-месяц в лучшем случае.

    В одной из систем, с которыми я работала, был точечный поиск. Не просто «найди мне все данные, где встречается «Ленина», а именно «найди мне адреса, у которых улица Ленина». Это отсеет фамилию Ленина, комментарий к телефону и другие нерелевантные данные.

    Но вот беда — нельзя поискать по двум параметрам ОДНОГО атрибута. Если сказать «Найди мне домашний адрес с улицей Ленина», система вернет:

    1. Васю: домашний адрес с улицей Ленина.

    2. Петю: домашний адрес с переулком Турчанинов и рабочий с улицей Ленина.

    Почему так? 

    Это баг в системе? Или просто нельзя сделать такой поиск, это неосуществимо? Нужно смотреть по коду.

    В той системе для поиска использовали Lucene. Его можно настроить по-разному:

    o   поиск по любому полю;

    o   поиск по конкретному полю;

    o   множественный поиск по конкретному атрибуту (в одном адресе проверить и тип, и улицу);

    o   ...

    Но! Чем сложнее сценарий поиска, тем медленнее он работает. Дольше сохраняет данные (потому что структура внутри усложняется), дольше ищет — или потребляет больше ресурсов для той же скорости.

    Когда данных с гулькин нос, это неважно. А когда их миллионы, нужно искать баланс. И такой выбор возможностей поиска — это именно компромис для скорости и потребляемых ресурсов под сценарии использования.

    Осуществимо желание отсеять Петю? Да. Но это просто не нужно. Потому что вреда принесет больше, чем пользы. Ради того, чтобы в выборку из 1000 человек не попали 10 лишних, платить несколько миллионов за дополнительные мощности серверов смысла просто нет.

 
6. Тестируемость

Можно ли протестировать этот функционал?

Подумайте об этом заранее. А то бывает так, что разработчик уже всё сделал, и тут только тестировщик понимает, что  задачу никак нельзя проверить. Или можно проверить вручную, но нельзя написать автотесты, фреймворк под новый функционал не заточен.

Если в компании принято все покрывать автотестами, то это станет проблемой. Может, разработчик прочитает ТЗ и сам поймет, что ещё фреймворк тестов дорабатывать надо. А может, он не вспомнит об этом. И тогда ваша задача — вспомнить. Чтобы сразу заложить время на доработки.

У меня бывали ситуации, когда мы делали задачу в текущем релизе, а потом ставили новую «Доработать фреймворк автоматизации, чтобы поддержать изменения» в следующий. Иногда забывали про фреймворк, а потом времени в релизе уже не оставалось. А иногда сразу понимали, что всё сразу сделать не успеем.

    Иногда про тесты не думаешь, так как уже есть похожие. Например, у нас давно были автотесты на обратный поток в JMS-очередь. А потом для одного из заказчиков мы сделали обратный поток в две JMS-очереди.

    Сначала я не подумала о доработке автотестов — ведь возможность проверить «что ушло» есть! А когда добралась до тестирования, пошла к разработчику:

    — А как мне указать вторую очередь? Или папка jms — это то, что в обе уйдет?

    — Хм, нет, погоди, это только в старую. Надо доделывать фреймворк, поддержать разные очереди.

    Ну и ничего, доделали, написала тестов!

Хотя лучше об этом помнить сразу, иначе велик шанс, что тестировать за вас придется разработчику. Или половину проверок переносить на следующую итерацию, что тоже не очень хорошо.

При этом бывает и так, что тестировать все равно придется разработчику. Скажем, когда делают рефакторинг, что может проверить тестировщик? Только регресс провести, посмотреть, что ничего не отломалось. А если есть автотесты, то это проверят они =)

Однако если тесты (авто или ручные) прошли успешно, это ещё не значит, что рефакторинг прошел хорошо. Сама суть рефакторинга — переписать код, чтобы он был более оптимален и читабелен. Чтобы его было легче поддерживать в дальнейшем и интегрировать с другими частями системы.

И именно это и надо проверить! А проверить это может только разработчик. Он и выполняет тестирование в данном случае.

 
Бонус: мнемоника CIRCUS MATTA и другие доп материалы

CIRCUS MATTA — мнемоника для ревью пользовательских историй. Это как раз про тестирование требований! Истории должны обладать качествами:

    Completeness — полнота

    Independent — независимость

    Realisable — реализуемость

    Consistency — консистентность

    Unambiguity — однозначность

    Specific — специфика заказчика

    Measurable — измеримая

    Acceptable — приемлемая

    Testable — тестируемая

    Traceable — трассируемая (можно проставить взаимосвязи)

    Achievable — достижимая

Вон сколько пунктов получилось! Мне особенно импонируют пункты «специфика заказчика» и «трассируемость». Это и правда важно. Если у вас коробочный продукт, который кастомизируется под заказчика, обязательно смотрите на пункт «Specific». А трассируемость — очень хороший бонус, облегчающий поддержку документации в актуальном состоянии!